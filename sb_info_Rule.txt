 «Морський бій» 
— гра для двох учасників, у якій гравці по черзі називають координати на невідомій їм карті суперника. Якщо у суперника в тому місці є корабель (координати зайняті), то корабель або його частина «тоне», а той, хто влучив, здобуває право зробити ще один хід. Мета гравця — першим потопити всі кораблі супротивника.

Консольна Гра "морський бій" реалізована на мові програмування C++ з 
використанням стандартних бібліотек вводу-виводу інформації в консоль, 
роботи з строками, файлами, потоками. 
Для реалізації мережевого режиму гри "кліент-сервер" використана бібліотека Socet 2.0.
В програмі реалізовані багатофункціональні режими роботи, а саме: 
1. Локальна гра, коли гра відбувається на одному робочому місті 
одного комп'ютера.
2. Мережева гра, коли гра може відбуватись на двох комп'ютерах, 
один з яких включається режим "сервер", на іншому режим "клієнт". 
Для цього створено перелік enum Game_Mode зі значеннями ::loc та  ::net, 
та глобальна змінна _Game_Mode, якій присвоюється бажаний режим гри.

перелік enum Game_Place зі значеннями ::comp,  
для локальнох або мережевої гри ::server, ::client, 
та глобальна змінна _Game_Place, якій присвоюється відповідне значення.

В програмі реалізовано режим гравця: 
1.Комп'ютер - коли постріли вибирає алгоритм програми.
2.Людина - коли постріли вводить з консолі гравець.
3.Клієнт для мережевої гри, коли постріли вводяться гравцем-людиною, 
або генеруються гравцем-комп`ютером на іншому комп'ютері та передаються через socet.
Для цього об'явлено enum class Player_Mode зі значеннями ::comp, ::human, ::client.

Спілкування оператора-гравця з програмою реалізовано через 

консольне меню. Для вибору необхідно вибрати номер пункту меню, або на пропозицію 
програми ввести значення, в деяких випадках допустимі значення обмежені за логічністю.

В програмі реалізовано змінні розміри ігрового поля - двомірний масив 
вказівників int ** mtx на вибір гравця. Для мережевої гри розмір визначає 
гравець на серверній машині. Розмір поля задається в змінну int sbf=10;
В результаті створюється 2 двомірних масиви mtx1, mtx2 для кожного гравця
 на початку гри та видаляються при закінченні функції гри.  
Звернення до елементу масиву відбувається як mtx[y][x], 
де y-номер строки в масиві x-номер колонки в масиві. 
В кожному з елементів зберігається ціле число, яке несе смислове навантаження відображене в 

enum PointVal {sea=0, // море без корабля
 ship1=1, ...// кораблі з палубами,
miss, //промазав
wound,//поранив
kill, //вбив
rezerv//резервування місця навколо кораблів
}

Гравці реалізовані в класі class Player. На початку гри сворюється 
2 примірники класу Player *pl1, *pl2, які використовуються на протязі дії всієї програми. 

Реалізовано декілько варіантів створення: без параметрів та з параметрами.
pl1= new Player(); //ініціалізація без параметрів
pl1= new Player("Ім'я", режим_гравця); //

ініціалізація без параметрів
class Player має наступні функції та змінні: Name, 
Player_Mode pm,//режим граця
Player_Level level, //рівень гравця комп'ютера
vector<myShot> myShots, //вектор-динамічний масив пострілів гравця, 
які пішли в залік
vector<myShot> myNewShots,//вектор-динамічний масив НОВИХ пострілів гравця, 
які створив гравець та які знаходяться в обробці до закінчення залпу з кількох пострілів

Головний режим гри
функція void M_Game() 
параметри передаються : нічого
параметри що повертаються : нічого

1. Гравцю пропонується вибрати режим гри: локальний або мережевий.

1.1. Для локальної гри …гра починається
1.2. Для мережевої гри пропонується вибрати робоче місце: сервер або клієнт.
1.2.1. Для серверного виконання :
пропонується вибрати гравця 1 або 2 на сервері, який стане віддаленим клієнтом та 
запускається сервер, 
чекається на підключення клієнтської програми
після підключення клієнта ключова інформація про гру передається клієнту
та чекається реакція клієнта.
1.2.2. Для клієнтського виконання :
запускається клієнтський режим програми 
проходить підключення до сервера
після підключення запускається обмін інформації від сервера до клієнта: 
назви гравців, кількість 

пострілів, розмір ігрового поля
обрабляється отримана інформація: переприсвоюються значення змінних, 
які отримані від сервера після присвоєння гравцю на клієнті який на 
сервері вибрано клієнтом пропонується вибрати тип гравця : комп'ютер або людина.
наприклад:
комп1.                                  комп2.
сервер.                                   клієнт
гравець1 назва1 / комп.  	назва1/ клієнт
гравець2 назва2 / клієнт 	назва2/ кома..людина

2. створюється 2 ігрових поля в залежності від вибраного розміру ігрового поля
поля заповняються 
      нулями
      кораблями- ескадрами кораблів для кожного гравця

з використанням генератора випадкових чисел та набору кораблів(з кількістю палуб),
 які потрібно розмістити: 4 шт …1 палубних, 3 шт ... 2 палубних, 2 ...3 палубних, 
1 шт... 4 палубних. Описано в 2мірному масиві Eskadra
відображаються ігрові поля в консолі. ігрові поля противника відображаться пустими.
 для локальної гри двох ботів відображаться оба поля зі значеннями.
3. Запускається два цикли
3.1. цикл гри для двох гравців
3.1.1. цикл пострілів гравця 1 (в мережевому варіанті також 1й грає гравець 1, 
за рахунок вивертання гравців на сервері та клієнті відбувається черговість та перехід ходу в подальшому)
Цикл Ходу гравця складається з 

пострілу, Shot(Player *pl, int **mtx)
відображення результату пострілу на карті Show2()
відображення результату в статистичному переліку пострілів та результатів цих пострілів.
перевіряється чи не став гравець переможцем або програвшим
цикл закінчується 
якщо у гравця невдалий постріл та гравець не отримав ще один постріл 
player->myShotRes !=ShotRes::TryShot
якщо гравець людина відмовівся від ходу та замість координат наступного пострілу ввів 0 ноль
якщо гравець не став переможцев або програвшим тобто залишився в грі  
player->stan !=Player_Stan::InGame?
3.1.2.Коли цикл гравця 1 закінчено відбувається перехід ходу до гравця 1 
і для нього запускається свій цикл.

3.1. закінчується коли хтось з гравців виграв або сдався.
Відображається остаточний результат гри. та виходить в головне меню.


Функция void Shot(Player *pl, int **mtx)
параметри передаються : 
1. Вказівник на Гравця Player *pl, який робить постріл
2. Вказівник на ігрове поле супротивника int **mtx
Наприклад: Shot(pl1,mtx2) або Shot(pl2,mtx1) 
параметри що повертаються : нічого

В тілі функції цикл поки гравець за результатом пострілу не має можливість 
повторити спробу пострілу 
player->myShotRes !=ShotRes::TryAgain
або не відмовився від пострілу
player->myShotRes !=ShotRes::Exit


(якщо вибрав ті координати, які вже вибирав, для комп'ютерного вибору 
координат пострілу буде багато повторів)
В тілі циклу відбувається 
Для локальної гри:
вибір координат для пострілу: функція string GetShot(Player *pl, int ** mtx)
виконання пострілу функція string string MakeShot(Player *pl, int ** mtx) 
нанесення на карту гри,  перевірка результатів 
Для мережевої гри:
на комп'ютері-сервері
для гравця комп'ютер/людина
вибір координат для пострілу: функція string GetShot(Player *pl, int ** mtx)
передача до клієнт-гравець списку пострілів на комп`ютер-клієнт
очікуються результати пострілу від 

комп`ютер-клієнт 
результати пострілів наносяться на пусте ігрове поле клієнт-гравець
виконання пострілу функція string string MakeShot(Player *pl, int ** mtx) 
нанесення на карту гри,  перевірка результатів

на комп`ютері-клієнті 
отримується список пострілів від клієнта-супротивника
від імені клієнт-гравець робиться постріл на заповнене ігрове поле супротивника  
гравця комп'ютер/людина, виконання пострілу функція 
string string MakeShot(Player *pl, int ** mtx) нанесення на карту гри,  
перевірка результатів передача результатів в зворотньому напрямку
При переході ходу выбір, передача, отримання, постріл, результат, 

прив`язка робляться в зворотньому напрямку.

Мережеві функції.
Для серверного режиму програми
RunServer - запуск сервера
SendMessageToClient - відправка повідомлення до клієнта
ReceiveMessageFromClient - отримання повідомлення від клієнта
StopServer - зупинка сервера

Для клієнтського режиму програми
RunClient - запуск клієнта
SendMessageToServer - відправка повідомлення до сервера
ReceiveMessageFromServer - отримання повідомлення від сервера
StopClient - зупинка клієнта


string ReceiveMessage() в залежності 
від режиму компа від сервера або від клієнта
SendSMS
WaitSMS
ApplyMessage() опрацювання повідомлення отриманого



Заповнення ігрового поля кораблями
в випадковому порядку виконується в два проходи 
1. Цикл по довіднику кораблів в ескадрі від самого великого за кількістю 
палуб до малих. Легше знайти вільний простір. 
2. Пробний цикл пошуку координат першої (лівої , верхної) палуби на карті 
від якої будується корабель. Координати точки випадкові. 
Випадково вибирається орієнтація корабля: горизонтально або вертикально. 
Якщо координати наступних палуб виходять  за межі карти, вибіраються нові 
координати початкової палуби та орієнтація корабля. Якщо корабель вміщується 
в карту, координати початкової палуби запамятовуються та починається другий 
цикл на якому новий корабель ставиться на карту int **mtx. 
Кожній комірці mtx присвоюється Значенення, яке дорівнює кількості палуб 
в кораблі 1,2,2,3,3,3,4,4,4,4 через PointVal::ship1,::ship2,::ship3,::ship4


string MakeShot(Player *pl, int **mtx)